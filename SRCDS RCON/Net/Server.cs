using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;

namespace SRCDS_RCON.Net
{
	// don't set the value manually on these
	// the index is linked to the value and it's important
	public enum ServerType : int
	{
		/// <summary>
		/// For Source Dedicated Server
		/// </summary>
		SRCDS,
		/// <summary>
		/// Minecraft servers follow the same RCON protocol.
		/// </summary>
		MINECRAFT
	}

	public class Server
	{
		public static string GetFriendlyTypeName(ServerType type)
		{
			Dictionary<ServerType, string> typeMap = new Dictionary<ServerType, string>
			{
				{ ServerType.SRCDS, "SRCDS" },
				{ ServerType.MINECRAFT, "Minecraft" }
			};

			return typeMap[type];
		}

		public string Hostname { get; set; } = string.Empty;
		public int Port { get; set; } = 0;
		public ServerType Type { get; set; } = ServerType.SRCDS;
		public string Password { get; set; } = string.Empty;

		/// <summary>
		/// Gets a <see cref="Server"/> from a string generated by <see cref="ToSerializedString"/>
		/// </summary>
		/// <param name="input"></param>
		/// <returns></returns>
		public static Server FromSerializedString(string input)
		{
			if (string.IsNullOrEmpty(input))
				return null;

			string hostname = "";
			string port = "";
			string password = "";
			string type = "";

			void appendValue(int index, char value)
			{
				switch (index)
				{
					case 0:
						hostname += value;
						break;
					case 1:
						port += value;
						break;
					case 2:
						password += value;
						break;
					case 3:
						type += value;
						break;
				}
			}

			try
			{
				for (int i = 0, k = 0; i < input.Length; i++)
				{
					// if the character is an escape character and there's something after it
					if (input[i] == '\\' && i < input.Length - 1)
					{
						// write whatever's after it and move on past it
						i++;
						appendValue(k, input[i]);
						continue;
					}

					// append k for each delimeter
					if (input[i] == ';')
					{
						k++;
						continue;
					}

					appendValue(k, input[i]);
				}

				return new Server()
				{
					Hostname = hostname,
					Port = int.Parse(port),
					Password = password,
					Type = (ServerType)Enum.Parse(typeof(ServerType), type)
				};
			}
			catch (Exception)
			{
				return null;
			}
		}

		/// <summary>
		/// Returns a serialized string for use with <see cref="FromSerializedString"/>
		/// </summary>
		/// <returns></returns>
		public string ToSerializedString()
		{
			return $"{escape(Hostname)};{escape(Port.ToString())};{escape(Password)};{(int)Type}";

			string escape(string input)
			{
				return input.Replace("\\", "\\\\").Replace(";", "\\;");
			}
		}

		/// <summary>
		/// Returns the string representation of the server
		/// </summary>
		/// <returns></returns>
		public override string ToString()
		{
			return $"{Hostname}:{Port} Password: {Password}";
		}

		public override int GetHashCode()
		{
			string hashable = Hostname + Port.ToString() + Type.ToString() + Password;
			return hashable.GetHashCode();
		}

		/// <summary>
		/// Returns whether this server equals another one
		/// </summary>
		/// <param name="obj"></param>
		/// <returns></returns>
		public override bool Equals(object obj)
		{
			Server s = (Server)obj;
			return AreEqual(s, this);
		}

		/// <summary>
		/// Determines whether two servers equal each other
		/// </summary>
		/// <param name="server1"></param>
		/// <param name="server2"></param>
		/// <returns></returns>
		public static bool AreEqual(Server server1, Server server2)
		{
			return server1.GetHashCode() == server2.GetHashCode();
		}
	}
}
